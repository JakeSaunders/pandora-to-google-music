#!/usr/bin/env python

from gmusicapi import Mobileclient
import re
from getpass import getpass
from termcolor import colored
from collections import defaultdict
import requests
from lxml import html
import unidecode
from jaro import jaro_winkler_metric as jaro_winkler

pandora_email = raw_input("Pandora email: ")
pandora_password = getpass("Pandora password: ")
gmusic_email = raw_input("Google Music email [%s]: " % pandora_email)
gmusic_password = getpass("Google Music password: ")

if gmusic_email == "":
    gmusic_email = pandora_email

gmusic_client = Mobileclient()
gmusic_client.login(gmusic_email, gmusic_password)

def normalise_metadata(value):
    """ Normalise a piece of song metadata for searching """

    # ASCII representation
    value = unidecode.unidecode(value)
    value = unicode(value)

    # Lowercase
    value = value.lower()

    # Remove secondary artists
    value = value.split(",")[0]
    value = re.sub(r"\([^\)]+\)|\[[^\]]+\]", "", value)
    value = re.sub(r"\bf(ea)?t\.?\b.+", "", value)

    # Remove extraneous whitespace
    value = re.sub(r"\s{2,}", " ", value)
    value = value.strip()

    return value

def fuzzy_artist_match(artist_a, artist_b):
    """ Check if the two artists are probably the same """

    return jaro_winkler(artist_a, artist_b) >= 0.7

def print_section_heading(heading):
    """ Print an underlined heading """

    print
    print "%s\n%s" % (heading, "=" * len(heading))

def print_gmusic_song(song, colour):
    print colored("%s - %s" % (song["track"]["artist"], song["track"]["title"]), colour)

def print_gmusic_songs(songs, colour):
    for song in songs:
        print_gmusic_song(song, colour)

def scrape_pandora_likes(email, password):
    """ Scrape likes from the Pandora web interface """

    s = requests.session()

    r = s.post("https://www.pandora.com/login.vm", data={
        "login_username": email,
        "login_password": password,
    })

    like_start_index = 0
    thumb_start_index = 0

    liked_songs = defaultdict(list)
    more_pages = True

    while more_pages:
        r = s.get("http://www.pandora.com/content/tracklikes", params={
            "likeStartIndex": like_start_index,
            "thumbStartIndex": thumb_start_index,
        })

        tree = html.fromstring(r.text)

        for element in tree.find_class("infobox-body"):
            title = unicode(element.find("h3").text_content())
            title = title.strip()

            artist = unicode(element.find("p").text_content())
            artist = artist.strip()
            artist = re.sub(r"^by\s+", "", artist)

            station_element = element.find_class("like_context_stationname")[0]
            station_name = unicode(station_element.text_content())
            station_name = station_name.strip()

            liked_songs[station_name].append((artist, title))

        more_elements = tree.find_class("show_more")

        # There are more pages
        if more_elements:
            like_start_index = more_elements[0].get("data-nextlikestartindex")
            thumb_start_index = more_elements[0].get("data-nextthumbstartindex")
        else:
            more_pages = False

    return liked_songs

def search_gmusic(gmusic_client, artist, title):
    """ Search Google Music for a song, returns the best match """

    def _search_strings(artist, title):
        yield artist + " " + title

        # Search again with the title normalised too
        title = normalise_metadata(title)
        yield artist + " " + title

    artist = normalise_metadata(artist)

    # No match
    status = 0
    best_match = None

    for search_string in _search_strings(artist, title):
        results = gmusic_client.search_all_access(search_string)["song_hits"]

        if results:
            result = results[0]

            # To stop spam songs being added to the playlist check that
            # the artists are roughly the same
            if fuzzy_artist_match(normalise_metadata(result["track"]["artist"]), artist):
                # Good match
                status = 2
                best_match = result
                break
            elif status == 0:
                # Spam
                status = 1
                best_match = result

    return status, best_match

pandora_likes = scrape_pandora_likes(pandora_email, pandora_password)

gmusic_match_count = 0
pandora_like_count = 0
pandora_stations = defaultdict(list)

# Match Pandora likes with Google Music
for station_name, songs in pandora_likes.items():
    pandora_like_count += len(songs)

    print_section_heading('Matching "%s"' % station_name)

    for song in songs:
        artist, title = song

        status, match = search_gmusic(gmusic_client, artist, title)

        if status == 2:
            pandora_stations[station_name].append(match)
            pandora_stations[None].append(match)
            gmusic_match_count += 1
            colour = "green"
        elif status == 1:
            colour = "magenta"
        else:
            colour = "red"

        print colored("%s - %s" % (artist, title), colour)

gmusic_playlists = gmusic_client.get_all_user_playlist_contents()
gmusic_playlist_map = {playlist["name"]: playlist for playlist in gmusic_playlists}
songs_added = 0
songs_removed = 0

# Update Google Music playlists
for pandora_station, pandora_songs in pandora_stations.items():
    # Playlist containing all songs liked on Pandora
    if pandora_station is None:
        pandora_station = "All"
        gmusic_playlist_name = "Pandora"
    # Station playlist
    else:
        gmusic_playlist_name = "Pandora - %s" % pandora_station

    print_section_heading('Syncing "%s"' % pandora_station)

    pandora_song_map = {song["track"]["nid"]: song for song in pandora_songs}

    # Get the playlist if it already exists
    gmusic_playlist = gmusic_playlist_map.get(gmusic_playlist_name)

    # Playlist doesn't exist so create it
    if gmusic_playlist is None:
        new_playlist = True

        gmusic_playlist_id = gmusic_client.create_playlist(gmusic_playlist_name)

        gmusic_add_song_ids = set(song["track"]["nid"] for song in pandora_songs)
        gmusic_remove_song_ids = set()
    # Playlist exists so update it
    else:
        new_playlist = False

        gmusic_playlist_id = gmusic_playlist["id"]

        # Find song ids to add and remove from the playlist
        gmusic_song_map = {song["trackId"]: song for song in gmusic_playlist["tracks"]}
        gmusic_song_ids = set(gmusic_song_map.keys())
        pandora_song_ids = set(pandora_song_map.keys())
        gmusic_add_song_ids = pandora_song_ids - gmusic_song_ids
        gmusic_remove_song_ids = gmusic_song_ids - pandora_song_ids

    if new_playlist:
        print colored("New playlist", "blue")
    else:
        # Check if the playlist needs to be updated
        if len(gmusic_add_song_ids) > 0 or len(gmusic_remove_song_ids) > 0:
            print colored("Updating playlist", "blue")
        else:
            print colored("Up to date", "blue")
            continue

    # Add songs to Google Music playlist
    gmusic_client.add_songs_to_playlist(gmusic_playlist_id, list(gmusic_add_song_ids))
    songs_added += len(gmusic_add_song_ids)

    gmusic_add_songs = [pandora_song_map[song_id] for song_id in gmusic_add_song_ids]

    print_gmusic_songs(gmusic_add_songs, "green")

    # Check if there are songs that need to be removed
    if gmusic_remove_song_ids:
        # Remove songs from Google Music playlist
        gmusic_remove_songs = [gmusic_song_map[song_id] for song_id in gmusic_remove_song_ids]
        gmusic_client.remove_entries_from_playlist([song["id"] for song in gmusic_remove_songs])
        songs_removed += len(gmusic_remove_song_ids)

        print_gmusic_songs(gmusic_remove_songs, "red")

print_section_heading("Summary")
print "matched %d/%d" % (gmusic_match_count, pandora_like_count)
print "added %d" % songs_added
print "removed %d" % songs_removed
